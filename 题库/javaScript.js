JavaScript
说一下原型链
	三个关键词：__proto__，prototype，constructor
	在引用类型中，都有一个__proto__属性，这个属性会指向创建当前类型的构造函数的原型prototype，
	这个原型是对象，也有__proto__属性，指向的是创建当前构造函数的构造函数的原型prototype，
	顺着__proto__往上找，最终会指向Object的原型prototypr，之后就是null。

	引用类型中之所以能够调用toString方法，就是因为通过原型链继承了来自Object原型prototype的方法。
	而consturctor是原型prototype的属性，指向的是函数本身，进而能够解释为什么被创建的对象能够通过constructor
	确认创建自己的构造函数

说一下继承
	六种
	原型链继承： Fun.prototype = new F() 新实例的原型指向父类的实例
	借用构造函数继承： F.call(this, 'tony') 只能继承父构造函数的属性
	组合继承：原型链继承与借用构造函数继承结合，克隆父构造函数属性又继承父类构造函数原型
	原型式继承：
	寄生式继承：
	寄生组合式继承：

new操作中发生了什么
	创建一个新的空对象，
	新的对象会被__proto__连接到构造函数的原型prototype

理解 JavaScript 中的执行上下文和执行栈
	执行上下文有：全局执行上下文（一个）、函数执行上下文（多个，执行函数时创建）eval执行上下文
	执行栈：先进后出原则执行全局执行上下文和函数执行上下文

说一下事件循环（event loop）
	宏任务：script、setTimeout、setInterval、I/O、UI交互事件、postMessage
	微任务:Promise.then、MutaionObserver、async await 之后代码
	当一个宏任务执行完毕，立即执行当前微任务队列中的所有微任务，页面渲染，之后再执行下一个宏任务，以此循环

说一下闭包
	本质是通过函数嵌套函数。通过函数内部可访问函数外部的参数及变量这一特性，将内部嵌套函数作为返回值时，
	函数的参数及变量不会被垃圾回收机制回收。因此消耗一定内存，但也保护了函数内部变量不会被污染。

谈一下垃圾回收
	为什么：为了避免内存泄漏，v8引擎会对没有引用到的对象或对象环进行回收处理
	怎么做：通过标记清除、引用计数等策略进行垃圾回收

聊一下内存泄漏

说一下函数柯里化
	把多参数传入的函数拆成部分函数，
	内部再返回调用下一个部分函数，依次处理剩余的参数。

说一下 var、let、const
	都会变量提升，let和const不会被初始化，var会初始化为undefined
	let和const只会在块级作用域生效、禁止重复声明变量、不会成为全局对象属性
	const定义的变量不能修改、必须初始化值
	
说一下call、apply、bind区别
	都是改变this指向
	call与apply的区别在于第一个参数之后，call是传的是实参列表，apply传的是数组或类数组
	call与bind区别在于，call是立即执行，bind不是

谈一下箭头函数与普通函数
	箭头函数是匿名函数，不能作为构造函数，没有原型，不能使用new，没有arguments，只能用解构 ... 解决 
	不绑定this，会捕获其所在的上下文的this值（箭头函数被定义时所在作用域的this），作为自己的this值，不能当做Generator函数

说一下this指向
	在函数调用时，才能确定this指向，谁调用指向谁，链式调用指向最后一个，没有明确调用对象，指向window
	一般函数this指向可用fun.call(context,obj1)理解，箭头函数不行

谈一下js严格模式
	提高代码健壮性，很多情况下，对于不会报错的语句，抛出错误提示并阻止执行代码	。
	全局作用域下的this是undefined，不是window
	
如何让事件先冒泡后捕获
	默认情况下，事件流的执行顺序是：先捕获，后冒泡。

	要想先冒泡后捕获，可以在添加监听事件时addEventListener第三个参数设置布尔值，
	true为捕获阶段触发事件，false为冒泡阶段触发事件。

	如果在一个元素上绑定捕获和冒泡两个阶段的事件，且触发事件的目标直接是当前元素时，
	冒泡和捕获两个事件执行的顺序是遵循js执行上下文去执行的。即将冒泡事件写在捕获事件前面，即可

	如果触发事件的目标是当前绑定事件元素的子元素，事件的执行顺序是先捕获，后冒泡，需要用setTimeout或者setinterval
	将监听到的捕获事件暂停，等待冒泡事件触发后再继续执行。

说说前端中的事件流
	描述的是事件发生的顺序
	包含三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段
	事件捕获阶段：自上而下，从window到目标元素
	事件冒泡阶段：自下而上，从目标元素到窗口

说一下事件委托
	为了减少dom操作，需要事件委托，进而提高性能。
	本质是通过事件冒泡，将事件绑定到目标元素的父元素上，触发事件时通过回调参数判定目标元素。

	