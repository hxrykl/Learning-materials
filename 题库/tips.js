JavaScript
说一下原型链
	三个关键词：__proto__，prototype，constructor
	在引用类型中，都有一个__proto__属性，这个属性会指向创建当前类型的构造函数的原型prototype，
	这个原型是对象，也有__proto__属性，指向的是创建当前构造函数的构造函数的原型prototype，
	顺着__proto__往上找，最终会指向Object的原型prototypr，之后就是null。
	引用类型中之所以能够调用toString方法，就是因为通过原型链继承了来自Object原型prototype的方法。
	而consturctor是原型prototype的属性，指向的是函数本身，进而能够解释为什么被创建的对象能够通过constructor
	确认创建自己的构造函数

说一下继承
	六种
	原型链继承： Fun.prototype = new F() 新实例的原型指向父类的实例
	借用构造函数继承： F.call(this, 'tony') 只能继承父构造函数的属性
	组合继承：原型链继承与借用构造函数继承结合，克隆父构造函数属性又继承父类构造函数原型
	原型式继承：
	寄生式继承：
	寄生组合式继承：


理解 JavaScript 中的执行上下文和执行栈
	执行上下文有：全局执行上下文（一个）、函数执行上下文（多个，执行函数时创建）
	执行栈：先进后出原则执行全局执行上下文和函数执行上下文

说一下闭包
	本质是通过函数嵌套函数，通过函数内部可访问函数外部的参数及变量这一特性，将内部嵌套函数作为返回值时，
	函数的参数及变量不会被垃圾回收机制回收。因此消耗一定内存，但也保护了函数内部变量不会被污染。

说一下函数柯里化
	把多参数传入的函数拆成部分函数，内部再返回调用下一个部分函数，依次处理剩余的参数。
	
说一下call、apply、bind区别
	都是改变this指向
	call与apply的区别在于第一个参数之后，call是传的是实参列表，apply传的是数组或类数组
	call与bind区别在于，call是立即执行，bind不是

谈一下箭头函数与普通函数
	箭头函数是匿名函数，不能作为构造函数，没有原型，不能使用new，没有arguments，只能用解构 ... 解决 
	不绑定this，会捕获其所在的上下文的this值，作为自己的this值，不能当做Generator函数
	
如何让事件先冒泡后捕获
	默认情况下，事件流的执行顺序是：先捕获，后冒泡。

	要想先冒泡后捕获，可以在添加监听事件时addEventListener第三个参数设置布尔值，
	true为捕获阶段触发事件，false为冒泡阶段触发事件。

	如果在一个元素上绑定捕获和冒泡两个阶段的事件，且触发事件的目标直接是当前元素时，
	冒泡和捕获两个事件执行的顺序是遵循js执行上下文去执行的。即将冒泡事件写在捕获事件前面，即可

	如果触发事件的目标是当前绑定事件元素的子元素，事件的执行顺序是先捕获，后冒泡，需要用setTimeout或者setinterval
	将监听到的捕获事件暂停，等待冒泡事件触发后再继续执行。

说说前端中的事件流
	描述的是事件发生的顺序
	包含三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段
	事件捕获阶段：自上而下，从window到目标元素
	事件冒泡阶段：自下而上，从目标元素到窗口

说一下事件委托
	为了减少dom操作，需要事件委托，进而提高性能。
	本质是通过事件冒泡，将事件绑定到目标元素的父元素上，触发事件时通过回调参数判定目标元素。

	