JavaScript
说一下原型链
	三个关键词：__proto__，prototype，constructor
	在引用类型中，都有一个__proto__属性，这个属性会指向创建当前类型的构造函数的原型prototype，
	这个原型是对象，也有__proto__属性，指向的是创建当前构造函数的构造函数的原型prototype，
	顺着__proto__往上找，最终会指向Object的原型prototypr，之后就是null。
	引用类型中之所以能够调用toString方法，就是因为通过原型链继承了来自Object原型prototype的方法。
	而consturctor是原型prototype的属性，指向的是函数本身，进而能够解释为什么被创建的对象能够通过constructor
	确认创建自己的构造函数

说一下继承
	六种
	原型链继承： Fun.prototype = new F()
	借用构造函数继承： F.call(this, 'tony')

理解 JavaScript 中的执行上下文和执行栈
	执行上下文有：全局执行上下文（一个）、函数执行上下文（多个，执行函数时创建）
	执行栈：先进后出原则执行全局执行上下文和函数执行上下文

说一下闭包
	
	
如何让事件先冒泡后捕获
	默认情况下，事件流的执行顺序是：先捕获，后冒泡。

	要想先冒泡后捕获，可以在添加监听事件时addEventListener第三个参数设置布尔值，
	true为捕获阶段触发事件，false为冒泡阶段触发事件。

	如果在一个元素上绑定捕获和冒泡两个阶段的事件，且触发事件的目标直接是当前元素时，
	冒泡和捕获两个事件执行的顺序是遵循js执行上下文去执行的。即将冒泡事件写在捕获事件前面，即可

	如果触发事件的目标是当前绑定事件元素的子元素，事件的执行顺序是先捕获，后冒泡，需要用setTimeout或者setinterval
	将监听到的捕获事件暂停，等待冒泡事件触发后再继续执行。

说说前端中的事件流
	描述的是事件发生的顺序
	包含三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段
	事件捕获阶段：自上而下，从window到目标元素
	事件冒泡阶段：自下而上，从目标元素到窗口

说一下事件委托
	为了减少dom操作，需要事件委托，进而提高性能。
	本质是通过事件冒泡，将事件绑定到目标元素的父元素上，触发事件时通过回调参数判定目标元素。

	